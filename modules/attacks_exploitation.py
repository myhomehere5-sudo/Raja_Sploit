#!/usr/bin/env python3
"""
attacks_exploitation.py

Menu launcher that prompts for required args and launches the real native tools
in the same terminal, captures results per-run, and can generate HTML + PDF reports.

Run from a real terminal:
    python3 attacks_exploitation.py
"""
import os
import sys
import shutil
import subprocess
import shlex
import time
import json
import base64
from io import BytesIO
from datetime import datetime
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from jinja2 import Template

# ReportLab for PDF
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak
from reportlab.lib.units import cm
from reportlab.lib.styles import getSampleStyleSheet

# ---------------- Colors ----------------
RESET = "\033[0m"
RED = "\033[1;31m"
GREEN = "\033[1;32m"
YELLOW = "\033[1;33m"
CYAN = "\033[1;36m"
MAGENTA = "\033[1;35m"

# ---------------- Utilities ----------------
def banner():
    os.system("clear")
    print(f"{CYAN}=== Attacks & Exploitation (Module 2) ==={RESET}\n")

def binary_exists(cmd):
    return shutil.which(cmd) is not None

def ensure_tty():
    if not (sys.stdin.isatty() and sys.stdout.isatty()):
        print(f"{YELLOW}This script must be run from a real terminal (not double-click).{RESET}")
        print("Open a terminal and run: python3 attacks_exploitation.py")
        try:
            input("Press Enter to exit.")
        except Exception:
            pass
        sys.exit(1)

def pause(msg="Press Enter to return to menu."):
    try:
        input(f"\n{msg}")
    except Exception:
        time.sleep(0.2)

def sh_quote(s):
    return shlex.quote(s)

# ---------------- Session directory & metadata ----------------
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
REPORTS_ROOT = os.path.join(BASE_DIR, "reports")
os.makedirs(REPORTS_ROOT, exist_ok=True)

def new_session_dir():
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    d = os.path.join(REPORTS_ROOT, f"session_{ts}")
    os.makedirs(d, exist_ok=True)
    return d

print(f"{MAGENTA}[+] Launching Attacks & Exploitation module...{RESET}")

# Create session dir now but do NOT prompt for report metadata yet.
SESSION_DIR = new_session_dir()

# Minimal META to track session start; will be augmented when generating report.
META = {
    "client": None,
    "creator": None,
    "started_at": datetime.now().isoformat(),
    "session_dir": SESSION_DIR
}

# Write a minimal session_meta.json now (so session folder contains metadata).
meta_path = os.path.join(SESSION_DIR, "session_meta.json")
with open(meta_path, "w", encoding="utf-8") as mf:
    json.dump(META, mf, indent=2)

def session_path(fname):
    return os.path.join(SESSION_DIR, fname)

# ---------------- Capturing helpers ----------------
USE_SCRIPT = shutil.which("script") is not None  # script is best for interactive capture

def _now_str():
    return datetime.now().strftime("%Y%m%d_%H%M%S")

def run_interactive_command(cmd_str, label):
    """
    Run a command string interactively in the same terminal and capture output.
    - If 'script' is available, uses it to capture a real TTY session.
    - Otherwise uses bash -ic "cmd | tee logfile" as a fallback.
    Saves a .log and .meta.json in session dir and returns meta dict.
    """
    start = datetime.now()
    safe_label = "".join(ch if ch.isalnum() or ch in '-_.' else '_' for ch in label)
    base = f"{start.strftime('%H%M%S')}_{safe_label}"
    logfile = session_path(base + ".log")
    metafile = session_path(base + ".meta.json")

    meta = {
        "label": label,
        "command": cmd_str,
        "start": start.isoformat(),
        "end": None,
        "returncode": None,
        "logfile": os.path.basename(logfile)
    }

    try:
        if USE_SCRIPT:
            # script -q -c "bash -ic 'cmd_str'" logfile
            wrapper = ['script', '-q', '-c', f"bash -ic {sh_quote(cmd_str)}", logfile]
            rc = subprocess.call(wrapper)
            meta['returncode'] = rc
        else:
            # fallback: attempt to use tee so user still sees output
            # note: some truly interactive programs may not behave perfectly w/ tee
            fallback_cmd = f"{cmd_str} 2>&1 | tee {sh_quote(logfile)}"
            rc = subprocess.call(['bash', '-ic', fallback_cmd])
            meta['returncode'] = rc
    except KeyboardInterrupt:
        meta['returncode'] = -1
    except Exception as e:
        meta['returncode'] = -2
        with open(logfile, "a", encoding='utf-8', errors='replace') as lf:
            lf.write(f"\n[ERROR] Exception running command: {e}\n")
    meta['end'] = datetime.now().isoformat()
    with open(metafile, "w", encoding="utf-8") as mf:
        json.dump(meta, mf, indent=2)
    return meta

def run_args_command(args_list, label):
    """
    Run args_list (executable + args) and capture output.
    Use this when you prefer a direct invocation rather than a shell string.
    """
    start = datetime.now()
    safe_label = "".join(ch if ch.isalnum() or ch in '-_.' else '_' for ch in label)
    base = f"{start.strftime('%H%M%S')}_{safe_label}"
    logfile = session_path(base + ".log")
    metafile = session_path(base + ".meta.json")
    meta = {
        "label": label,
        "command": " ".join(sh_quote(x) for x in args_list),
        "start": start.isoformat(),
        "end": None,
        "returncode": None,
        "logfile": os.path.basename(logfile)
    }
    try:
        with open(logfile, "wb") as lf:
            p = subprocess.Popen(args_list, stdout=lf, stderr=subprocess.STDOUT)
            rc = p.wait()
            meta['returncode'] = rc
    except KeyboardInterrupt:
        meta['returncode'] = -1
    except Exception as e:
        meta['returncode'] = -2
        with open(logfile, "a", encoding='utf-8', errors='replace') as lf:
            lf.write(f"\n[ERROR] Exception running args_list: {e}\n")
    meta['end'] = datetime.now().isoformat()
    with open(metafile, "w", encoding="utf-8") as mf:
        json.dump(meta, mf, indent=2)
    return meta

# ---------------- Helpers for logs ----------------
def read_tail(filepath, lines=200, chars=2000):
    try:
        with open(filepath, "rb") as f:
            f.seek(0, 2)
            size = f.tell()
            read_sz = min(size, 200000)
            f.seek(max(size - read_sz, 0))
            data = f.read().decode(errors='replace')
        if len(data) > chars:
            data = data[-chars:]
        parts = data.splitlines()
        if len(parts) > lines:
            parts = parts[-lines:]
        return "\n".join(parts)
    except Exception as e:
        return f"(failed to read log: {e})"

# ---------------- Report generation ----------------
HTML_TEMPLATE = """
<!doctype html>
<html>
<head><meta charset="utf-8"><title>{{ title }}</title>
<style>
body{font-family:Arial; margin:20px; background:#fbfbfd; color:#222}
h1{color:#113366}
.card{background:#fff;border-radius:6px;padding:12px;margin:12px 0;box-shadow:0 2px 6px rgba(0,0,0,0.05)}
pre{background:#f5f7fb;padding:8px;border-radius:6px;overflow:auto;max-height:300px}
.small{font-size:0.9em;color:#555}
.chart{max-width:900px}
</style>
</head>
<body>
<h1>{{ title }}</h1>
<p class="small">Client: <strong>{{ client }}</strong> | Creator: <strong>{{ creator }}</strong> | Generated: {{ generated_time }}</p>

<div class="card">
<h2>Summary</h2>
<p>{{ summary_text }}</p>
{% if overall_chart %}
<div class="chart"><img src="data:image/png;base64,{{ overall_chart }}" alt="overall chart"></div>
{% endif %}
</div>

{% for tool in tools %}
<div class="card">
<h3>{{ loop.index }}. {{ tool.label }}</h3>
<p class="small">Command: <code>{{ tool.command }}</code></p>
<p class="small">Start: {{ tool.start }} — End: {{ tool.end }} — Return code: {{ tool.returncode }}</p>
<p><strong>Tail of output:</strong></p>
<pre>{{ tool.tail }}</pre>
{% if tool.chart %}
<div class="chart"><img src="data:image/png;base64,{{ tool.chart }}" alt="tool chart"></div>
{% endif %}
</div>
{% endfor %}
</body>
</html>
"""

def build_chart_for_counts(counts_dict, title="Runs"):
    if not counts_dict:
        return None
    labels = list(counts_dict.keys())
    values = [counts_dict[k] for k in labels]
    plt.figure(figsize=(7,3))
    plt.bar(labels, values, alpha=0.85)
    plt.title(title)
    plt.tight_layout()
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150)
    plt.close()
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('ascii')

def build_success_chart(records, label):
    succ = sum(1 for r in records if r.get('returncode') == 0)
    fail = len(records) - succ
    if len(records) == 0:
        return None
    plt.figure(figsize=(4,2.3))
    plt.bar(['success','failure'], [succ, fail])
    plt.title(f"{label} success vs failure")
    plt.tight_layout()
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150)
    plt.close()
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('ascii')

def collect_metas():
    metas = []
    for fn in sorted(os.listdir(SESSION_DIR)):
        if fn.endswith(".meta.json"):
            path = os.path.join(SESSION_DIR, fn)
            try:
                with open(path, encoding='utf-8') as mf:
                    m = json.load(mf)
                    metas.append(m)
            except Exception:
                continue
    return metas

def prompt_for_report_metadata():
    """
    Ask user for client and creator info at the time of report generation.
    Update global META and write session_meta.json.
    """
    global META
    print("\nReport metadata — leave blank for defaults.")
    client = input("Report - Client name (for title) [default: UnknownClient]: ").strip()
    creator = input("Report - Creator name [default: UnknownCreator]: ").strip()
    if not client:
        client = "UnknownClient"
    if not creator:
        creator = "UnknownCreator"
    META['client'] = client
    META['creator'] = creator
    # Update started_at to original started_at if present; keep it.
    META['generated_at'] = datetime.now().isoformat()
    # save updated meta
    try:
        with open(os.path.join(SESSION_DIR, "session_meta.json"), "w", encoding="utf-8") as mf:
            json.dump(META, mf, indent=2)
    except Exception:
        pass

def generate_report():
    # Prompt for metadata now (only when user explicitly asks to generate report)
    prompt_for_report_metadata()

    metas = collect_metas()
    if not metas:
        print(f"{YELLOW}[!] No recorded activities in session to report.{RESET}")
        pause()
        return

    # attach tail logs and normalize returncodes
    for m in metas:
        logfp = os.path.join(SESSION_DIR, m.get('logfile',''))
        m['tail'] = read_tail(logfp) if os.path.exists(logfp) else "(log missing)"
        if 'returncode' not in m:
            m['returncode'] = None

    # overall chart (runs per tool)
    counts = {}
    by_tool = {}
    for m in metas:
        counts[m['label']] = counts.get(m['label'], 0) + 1
        by_tool.setdefault(m['label'], []).append(m)

    overall_chart_b64 = build_chart_for_counts(counts, title="Runs per tool (session)")

    # per-tool charts (success/failure)
    tool_charts = {}
    for label, recs in by_tool.items():
        tool_charts[label] = build_success_chart(recs, label)

    # render html
    rendered = Template(HTML_TEMPLATE).render(
        title=f"Session Report — {META.get('client','UnknownClient')}",
        client=META.get('client','UnknownClient'),
        creator=META.get('creator','UnknownCreator'),
        generated_time=datetime.now().isoformat(),
        summary_text=f"Recorded {len(metas)} executions in this session.",
        overall_chart=overall_chart_b64,
        tools=[{
            "label": m['label'],
            "command": m.get('command',''),
            "start": m.get('start',''),
            "end": m.get('end',''),
            "returncode": m.get('returncode'),
            "tail": m.get('tail',''),
            "chart": tool_charts.get(m['label'])
        } for m in metas]
    )

    # sanitize filename (remove colons)
    started_safe = META.get('started_at', datetime.now().isoformat()).replace(':','')
    html_path = session_path(f"report_{META.get('client','Unknown')}_{started_safe}.html")
    with open(html_path, "w", encoding='utf-8') as hf:
        hf.write(rendered)
    print(f"{GREEN}[+] HTML report saved to: {html_path}{RESET}")

    # --- PDF generation using ReportLab ---
    pdf_path = session_path(f"report_{META.get('client','Unknown')}_{started_safe}.pdf")
    doc = SimpleDocTemplate(pdf_path, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    elements = []
    elements.append(Paragraph(f"Session Report — {META.get('client','Unknown')}", styles['Title']))
    elements.append(Spacer(1, 0.2*cm))
    elements.append(Paragraph(f"Creator: {META.get('creator','Unknown')} | Generated: {datetime.now().isoformat()}", styles['Normal']))
    elements.append(Spacer(1, 0.2*cm))
    elements.append(Paragraph(f"Summary: Recorded {len(metas)} executions in this session.", styles['Normal']))
    elements.append(Spacer(1, 0.4*cm))

    # overall chart image
    if overall_chart_b64:
        overall_path = session_path("__overall_chart.png")
        with open(overall_path, "wb") as f:
            f.write(base64.b64decode(overall_chart_b64))
        elements.append(Image(overall_path, width=16*cm, height=8*cm))
        elements.append(Spacer(1, 0.4*cm))

    # each meta
    for m in metas:
        elements.append(Paragraph(f"{m.get('label')}", styles['Heading2']))
        elements.append(Paragraph(f"Command: {m.get('command','')}", styles['Code']))
        elements.append(Paragraph(f"Start: {m.get('start','')} — End: {m.get('end','')}", styles['Normal']))
        elements.append(Paragraph(f"Return code: {m.get('returncode')}", styles['Normal']))
        elements.append(Spacer(1, 0.1*cm))
        elements.append(Paragraph("Output (tail):", styles['Normal']))
        # Replace newlines with <br/> for Paragraph
        tail_html = m.get('tail','').replace('\n', '<br/>')
        elements.append(Paragraph(tail_html, styles['Code']))
        elements.append(Spacer(1, 0.2*cm))
        # per-tool chart
        tc_b64 = tool_charts.get(m['label'])
        if tc_b64:
            # safe filename per label
            label_safe = "".join(ch if ch.isalnum() or ch in '-_.' else '_' for ch in m['label'])
            tc_path = session_path(f"__chart_{label_safe}.png")
            # each tool chart might be reused; write if not exists
            if not os.path.exists(tc_path):
                with open(tc_path, "wb") as f:
                    f.write(base64.b64decode(tc_b64))
            elements.append(Image(tc_path, width=12*cm, height=5*cm))
            elements.append(Spacer(1, 0.2*cm))
        elements.append(PageBreak())

    try:
        doc.build(elements)
        print(f"{GREEN}[+] PDF report saved to: {pdf_path}{RESET}")
    except Exception as e:
        print(f"{RED}[!] PDF generation failed: {e}{RESET}")

# ---------------- Tool wrappers (run in same terminal) ----------------
def msf_action():
    if not binary_exists('msfconsole'):
        print(f"{RED}[!] msfconsole not found in PATH.{RESET}")
        pause()
        return
    print(f"{MAGENTA}[+] Launching Metasploit (msfconsole) in this terminal...{RESET}")
    meta = run_interactive_command('msfconsole', 'msfconsole')
    print(f"{GREEN}[+] msfconsole finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def setoolkit_action():
    # Run setoolkit as root if necessary
    if not binary_exists('setoolkit'):
        print(f"{RED}[!] setoolkit not found in PATH. Install with: sudo apt install setoolkit{RESET}")
        pause()
        return
    cmd = 'setoolkit' if os.geteuid() == 0 else 'sudo setoolkit'
    print(f"{MAGENTA}[+] Launching SET Toolkit in this terminal...{RESET}")
    meta = run_interactive_command(cmd, 'setoolkit')
    print(f"{GREEN}[+] setoolkit finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def hydra_action():
    if not binary_exists('hydra'):
        print(f"{RED}[!] hydra not found in PATH.{RESET}")
        pause()
        return
    print("\nHydra — choose how to run:")
    print("  1) Quick preset (fill target & hit enter)")
    print("  2) Custom full command (you will enter raw hydra args)")
    print("  0) Back")
    choice = input("Choice > ").strip()
    if choice == "0":
        return
    if choice == "2":
        raw = input("Enter raw hydra command (example: hydra -l root -P /path/rockyou.txt ssh://10.11.11.5):\n> ").strip()
        if not raw:
            print("Cancelled.")
            return
        meta = run_interactive_command(raw, 'hydra')
        print(f"{GREEN}[+] hydra finished (rc={meta.get('returncode')}).{RESET}")
        pause()
        return

    target = input("Target IP/hostname (e.g. 10.11.11.5): ").strip()
    if not target:
        print("No target provided.")
        pause()
        return
    service = input("Service (ssh/ftp/http-get etc) [default: ssh]: ").strip() or "ssh"
    username = input("Single username (leave blank to use username file): ").strip()
    if username:
        user_part = f"-l {sh_quote(username)}"
    else:
        uname_file = input("Path to username file: ").strip()
        if not uname_file or not os.path.isfile(uname_file):
            print(f"{RED}Username file missing or invalid: {uname_file}{RESET}")
            pause()
            return
        user_part = f"-L {sh_quote(uname_file)}"
    pass_file = input("Path to password list (e.g. /usr/share/wordlists/rockyou.txt): ").strip()
    if not pass_file or not os.path.isfile(pass_file):
        print(f"{RED}Password file missing or invalid: {pass_file}{RESET}")
        pause()
        return
    threads = input("Max parallel tasks (recommended 1-8) [default 4]: ").strip() or "4"
    stop_on_success = input("Stop when credentials found? (Y/n) [default Y]: ").strip().lower()
    stop_flag = "-f" if stop_on_success in ("", "y", "yes") else ""
    service_uri = service if "://" in service else f"{service}://{target}"
    cmd = f"hydra {user_part} -P {sh_quote(pass_file)} -t {sh_quote(threads)} {stop_flag} {service_uri}"
    meta = run_interactive_command(cmd, 'hydra')
    print(f"{GREEN}[+] hydra finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def john_action():
    if not binary_exists('john'):
        print(f"{RED}[!] john not found in PATH.{RESET}")
        pause()
        return
    print("\nJohn the Ripper — choose mode:")
    print("  1) Run with wordlist and hash file (common)")
    print("  2) Raw custom command")
    print("  0) Back")
    c = input("Choice > ").strip()
    if c == "0":
        return
    if c == "2":
        raw = input("Enter raw john command (example: john --wordlist=/path/rockyou.txt hashfile):\n> ").strip()
        if not raw:
            return
        meta = run_interactive_command(raw, 'john')
        print(f"{GREEN}[+] john finished (rc={meta.get('returncode')}).{RESET}")
        pause()
        return
    hash_file = input("Path to hash file: ").strip()
    if not hash_file or not os.path.isfile(hash_file):
        print(f"{RED}Hash file missing: {hash_file}{RESET}")
        pause()
        return
    wordlist = input("Path to wordlist (leave blank to use john default): ").strip()
    if wordlist:
        cmd = f"john --wordlist={sh_quote(wordlist)} {sh_quote(hash_file)}"
    else:
        cmd = f"john {sh_quote(hash_file)}"
    meta = run_interactive_command(cmd, 'john')
    print(f"{GREEN}[+] john finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def aircrack_action():
    if not binary_exists('aircrack-ng'):
        print(f"{RED}[!] aircrack-ng not found in PATH.{RESET}")
        pause()
        return
    print("\nAircrack-ng options:")
    print("  1) Run aircrack-ng on capture file with wordlist")
    print("  2) Open airodump-ng (collect capture) using an interface (opens interactive shell)")
    print("  3) Raw custom command")
    print("  0) Back")
    c = input("Choice > ").strip()
    if c == "0":
        return
    if c == "3":
        raw = input("Enter raw command:\n> ").strip()
        if not raw:
            return
        meta = run_interactive_command(raw, 'aircrack-ng-custom')
        print(f"{GREEN}[+] aircrack (custom) finished (rc={meta.get('returncode')}).{RESET}")
        pause()
        return
    if c == "2":
        iface = input("Monitor interface (e.g. wlan0mon) or interface to put into monitor mode (wlan0): ").strip()
        if not iface:
            print("No interface provided.")
            pause()
            return
        if binary_exists('airmon-ng'):
            print("Starting monitor mode (airmon-ng)...")
            subprocess.call(['sudo','airmon-ng','start', iface])
            print("Monitor mode command executed. You will now be dropped to a shell for airodump-ng (use Ctrl+C to stop).")
        # open interactive shell with hints, capture the session
        hints = f"echo 'Run airodump-ng example: sudo airodump-ng {iface}mon --write capturefile'; exec bash"
        meta = run_interactive_command(hints, 'airodump-shell')
        print(f"{GREEN}[+] airodump/monitor session ended (rc={meta.get('returncode')}).{RESET}")
        pause()
        return

    # option 1
    cap = input("Path to capture file (.cap): ").strip()
    if not cap or not os.path.isfile(cap):
        print(f"{RED}Capture file not found: {cap}{RESET}")
        pause()
        return
    wordlist = input("Path to wordlist (e.g. /usr/share/wordlists/rockyou.txt): ").strip()
    if not wordlist or not os.path.isfile(wordlist):
        print(f"{RED}Wordlist not found: {wordlist}{RESET}")
        pause()
        return
    cmd = f"aircrack-ng -w {sh_quote(wordlist)} {sh_quote(cap)}"
    meta = run_interactive_command(cmd, 'aircrack-ng')
    print(f"{GREEN}[+] aircrack-ng finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def sqlmap_action():
    if not binary_exists('sqlmap'):
        print(f"{RED}[!] sqlmap not found in PATH.{RESET}")
        pause()
        return
    url = input("Target URL (example: http://target/vuln.php?id=1): ").strip()
    if not url:
        print("No URL provided.")
        pause()
        return
    extra = input("Additional SQLMap options (or press Enter for --batch): ").strip()
    if extra:
        cmd = f"sqlmap -u {sh_quote(url)} {extra}"
    else:
        cmd = f"sqlmap -u {sh_quote(url)} --batch"
    meta = run_interactive_command(cmd, 'sqlmap')
    print(f"{GREEN}[+] sqlmap finished (rc={meta.get('returncode')}).{RESET}")
    pause()

def custom_phish_action():
    base = "/home/kali/EHSFB-Phish"
    if not os.path.exists(base):
        print(f"{RED}[!] Folder not found: {base}{RESET}")
        pause()
        return
    # If executable file at base, run it
    if os.path.isfile(base) and os.access(base, os.X_OK):
        meta = run_interactive_command(sh_quote(base), 'EHSFB-Phish-exe')
        print(f"{GREEN}[+] EHSFB-Phish finished (rc={meta.get('returncode')}).{RESET}")
        pause()
        return
    start_sh = os.path.join(base, "start.sh")
    if os.path.exists(start_sh):
        meta = run_interactive_command(f"cd {sh_quote(base)} && bash start.sh", 'EHSFB-Phish-start')
        print(f"{GREEN}[+] EHSFB-Phish start.sh finished (rc={meta.get('returncode')}).{RESET}")
        pause()
        return
    # otherwise open an interactive shell in that folder
    meta = run_interactive_command(f'cd {sh_quote(base)}; exec bash', 'EHSFB-Phish-shell')
    print(f"{GREEN}[+] Phish shell session ended (rc={meta.get('returncode')}).{RESET}")
    pause()

# ---------------- Menu & Main ----------------
def menu():
    banner()
    print(f"{GREEN}1){RESET} Metasploit (msfconsole)")
    print(f"{GREEN}2){RESET} Hydra")
    print(f"{GREEN}3){RESET} John the Ripper")
    print(f"{GREEN}4){RESET} SQLMap")
    print(f"{GREEN}5){RESET} Aircrack-ng")
    print(f"{GREEN}6){RESET} SET Toolkit")
    print(f"{GREEN}7){RESET} Phishing (EHSFB-Phish -- 'comming soon')")
    print(f"{GREEN}8){RESET} Generate Report (HTML + PDF")
    print(f"{GREEN}0){RESET} Exit")
    return input(f"\n{CYAN}Attacks > {RESET}").strip()

def main():
    ensure_tty()
    while True:
        choice = menu()
        if choice == "1":
            msf_action()
        elif choice == "2":
            hydra_action()
        elif choice == "3":
            john_action()
        elif choice == "4":
            sqlmap_action()
        elif choice == "5":
            aircrack_action()
        elif choice == "6":
            setoolkit_action()
        elif choice == "7":
            custom_phish_action()
        elif choice == "8":
            generate_report()
            pause()
        elif choice == "0":
            print("Exiting...")
            time.sleep(0.1)
            break
        else:
            print(f"{RED}[!] Invalid choice{RESET}")
            time.sleep(0.4)

if __name__ == "__main__":
    main()
